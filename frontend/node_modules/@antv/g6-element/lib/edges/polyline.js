"use strict";

var _tslib = require("tslib");
var _util = require("@antv/util");
var _g6Core = require("@antv/g6-core");
var _polylineUtil = require("./polyline-util");
var _router = require("./router");
// 折线
(0, _g6Core.registerEdge)('polyline', {
  options: {
    color: _g6Core.BaseGlobal.defaultEdge.color,
    size: _g6Core.BaseGlobal.defaultEdge.size,
    style: {
      radius: 0,
      offset: 15,
      x: 0,
      y: 0,
      stroke: _g6Core.BaseGlobal.defaultEdge.style.stroke,
      lineAppendWidth: _g6Core.BaseGlobal.defaultEdge.style.lineAppendWidth
    },
    // 文本样式配置
    labelCfg: {
      style: {
        fill: _g6Core.BaseGlobal.edgeLabel.style.fill,
        fontSize: _g6Core.BaseGlobal.edgeLabel.style.fontSize,
        fontFamily: _g6Core.BaseGlobal.windowFontFamily
      }
    },
    routeCfg: {
      obstacles: [],
      maxAllowedDirectionChange: Math.PI,
      maximumLoops: 500,
      gridSize: 10 // 指定精度
    },

    stateStyles: (0, _tslib.__assign)({}, _g6Core.BaseGlobal.edgeStateStyles)
  },
  shapeType: 'polyline',
  // 文本位置
  labelPosition: 'center',
  drawShape: function drawShape(cfg, group) {
    var shapeStyle = this.getShapeStyle(cfg);
    if (shapeStyle.radius === 0) delete shapeStyle.radius;
    var keyShape = group.addShape('path', {
      className: 'edge-shape',
      name: 'edge-shape',
      attrs: shapeStyle
    });
    group['shapeMap']['edge-shape'] = keyShape;
    return keyShape;
  },
  getShapeStyle: function getShapeStyle(cfg) {
    var defaultStyle = this.options.style;
    var strokeStyle = {
      stroke: cfg.color
    };
    var style = (0, _util.mix)({}, defaultStyle, strokeStyle, cfg.style);
    cfg = this.getPathPoints(cfg);
    this.radius = style.radius;
    this.offset = style.offset;
    var startPoint = cfg.startPoint,
      endPoint = cfg.endPoint;
    var controlPoints = this.getControlPoints(cfg);
    var points = [startPoint]; // 添加起始点
    // 添加控制点
    if (controlPoints) {
      points = points.concat(controlPoints);
    }
    // 添加结束点
    points.push(endPoint);
    var source = cfg.sourceNode;
    var target = cfg.targetNode;
    var radius = style.radius;
    var defaultRouteCfg = this.options.routeCfg;
    var routeCfg = (0, _util.mix)({}, defaultRouteCfg, cfg.routeCfg);
    routeCfg.offset = style.offset;
    var path = this.getPath(points, source, target, radius, routeCfg, !Boolean(controlPoints));
    if ((0, _util.isArray)(path) && path.length <= 1 || (0, _util.isString)(path) && path.indexOf('L') === -1) {
      path = 'M0 0, L0 0';
    }
    if (isNaN(startPoint.x) || isNaN(startPoint.y) || isNaN(endPoint.x) || isNaN(endPoint.y)) {
      path = 'M0 0, L0 0';
    }
    var attrs = (0, _util.mix)({}, _g6Core.BaseGlobal.defaultEdge.style, style, {
      lineWidth: cfg.size,
      path: path
    });
    return attrs;
  },
  updateShapeStyle: function updateShapeStyle(cfg, item) {
    var group = item.getContainer();
    if (!item.isVisible()) return;
    var strokeStyle = {
      stroke: cfg.color
    };
    var shape = group['shapeMap']['edge-shape'] || group.find(function (element) {
      return element.get('className') === 'edge-shape';
    }) || item.getKeyShape();
    var size = cfg.size;
    cfg = this.getPathPoints(cfg);
    var startPoint = cfg.startPoint,
      endPoint = cfg.endPoint;
    var controlPoints = this.getControlPoints(cfg); // || cfg.controlPoints;
    var points = [startPoint]; // 添加起始点
    // 添加控制点
    if (controlPoints) {
      points = points.concat(controlPoints);
    }
    // 添加结束点
    points.push(endPoint);
    var currentAttr = shape.attr();
    var previousStyle = (0, _util.mix)({}, strokeStyle, currentAttr, cfg.style);
    var source = cfg.sourceNode;
    var target = cfg.targetNode;
    var radius = previousStyle.radius;
    var defaultRouteCfg = this.options.routeCfg;
    var routeCfg = (0, _util.mix)({}, defaultRouteCfg, cfg.routeCfg);
    routeCfg.offset = previousStyle.offset;
    var path = this.getPath(points, source, target, radius, routeCfg, !Boolean(controlPoints));
    if ((0, _util.isArray)(path) && path.length <= 1 || (0, _util.isString)(path) && path.indexOf('L') === -1) {
      path = 'M0 0, L0 0';
    }
    if (isNaN(startPoint.x) || isNaN(startPoint.y) || isNaN(endPoint.x) || isNaN(endPoint.y)) {
      path = 'M0 0, L0 0';
    }
    if (currentAttr.endArrow && previousStyle.endArrow === false) {
      cfg.style.endArrow = {
        path: ''
      };
    }
    if (currentAttr.startArrow && previousStyle.startArrow === false) {
      cfg.style.startArrow = {
        path: ''
      };
    }
    var style = (0, _util.mix)(strokeStyle, shape.attr(), {
      lineWidth: size,
      path: path
    }, cfg.style);
    if (shape) {
      shape.attr(style);
    }
  },
  getPath: function getPath(points, source, target, radius, routeCfg, auto) {
    var offset = routeCfg.offset,
      obstacles = routeCfg.obstacles;
    var simple = routeCfg.simple;
    // 指定了控制点
    if (!offset || points.length > 2 || auto === false) {
      if (radius) {
        return (0, _polylineUtil.getPathWithBorderRadiusByPolyline)(points, radius);
      }
      var pathArray_1 = [];
      (0, _util.each)(points, function (point, index) {
        if (index === 0) {
          pathArray_1.push(['M', point.x, point.y]);
        } else {
          pathArray_1.push(['L', point.x, point.y]);
        }
      });
      return pathArray_1;
    }
    // 未指定控制点
    if (simple !== false && !(obstacles === null || obstacles === void 0 ? void 0 : obstacles.length)) simple = true;
    var polylinePoints = simple ? (0, _polylineUtil.getPolylinePoints)(points[points.length - 1], points[0], target, source, offset) : (0, _router.pathFinder)(points[0], points[points.length - 1], source, target, routeCfg);
    if (!polylinePoints || !polylinePoints.length) return 'M0 0, L0 0';
    if (radius) {
      var res_1 = (0, _polylineUtil.getPathWithBorderRadiusByPolyline)(polylinePoints, radius);
      return res_1;
    }
    // 去除连续同 x 不同 y 的中间点；去除连续同 y 不同 x 的中间点
    polylinePoints = (0, _polylineUtil.removeRedundantPoint)(polylinePoints);
    var res = _g6Core.Util.pointsToPolygon(polylinePoints);
    return res;
  }
}, 'single-edge');