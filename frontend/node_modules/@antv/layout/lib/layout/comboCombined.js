"use strict";
/**
 * @fileOverview Combo force layout
 * @author shiwu.wyy@antfin.com
 */
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ComboCombinedLayout = void 0;
var constants_1 = require("./constants");
var base_1 = require("./base");
var util_1 = require("../util");
var _1 = require(".");
/**
 * combined two layouts (inner and outer) for graph with combos
 */
var ComboCombinedLayout = /** @class */ (function (_super) {
    __extends(ComboCombinedLayout, _super);
    function ComboCombinedLayout(options) {
        var _this = _super.call(this) || this;
        /** 布局中心 */
        _this.center = [0, 0];
        /** 内部计算参数 */
        _this.nodes = [];
        _this.edges = [];
        _this.combos = [];
        _this.comboEdges = [];
        /** Combo 内部的 padding */
        _this.comboPadding = 10;
        _this.comboTrees = [];
        _this.updateCfg(options);
        return _this;
    }
    ComboCombinedLayout.prototype.getDefaultCfg = function () {
        return {};
    };
    /**
     * 执行布局
     */
    ComboCombinedLayout.prototype.execute = function () {
        var self = this;
        var nodes = self.nodes;
        var center = self.center;
        if (!nodes || nodes.length === 0) {
            if (self.onLayoutEnd)
                self.onLayoutEnd();
            return;
        }
        if (nodes.length === 1) {
            nodes[0].x = center[0];
            nodes[0].y = center[1];
            if (self.onLayoutEnd)
                self.onLayoutEnd();
            return;
        }
        self.initVals();
        // layout
        self.run();
        if (self.onLayoutEnd)
            self.onLayoutEnd();
    };
    ComboCombinedLayout.prototype.run = function () {
        var _a;
        var self = this;
        var nodes = self.nodes, edges = self.edges, combos = self.combos, comboEdges = self.comboEdges, center = self.center;
        var nodeMap = {};
        nodes.forEach(function (node) {
            nodeMap[node.id] = node;
        });
        var comboMap = {};
        combos.forEach(function (combo) {
            comboMap[combo.id] = combo;
        });
        var innerGraphs = self.getInnerGraphs(nodeMap);
        // 每个 innerGraph 作为一个节点，带有大小，参与 force 计算
        var outerNodeIds = [];
        var outerNodes = [];
        var nodeAncestorIdMap = {};
        var allHaveNoPosition = true;
        this.comboTrees.forEach(function (cTree) {
            var innerNode = innerGraphs[cTree.id];
            // 代表 combo 的节点
            var oNode = __assign(__assign({}, cTree), { x: innerNode.x || comboMap[cTree.id].x, y: innerNode.y || comboMap[cTree.id].y, fx: innerNode.fx || comboMap[cTree.id].fx, fy: innerNode.fy || comboMap[cTree.id].fy, mass: innerNode.mass || comboMap[cTree.id].mass, size: innerNode.size });
            outerNodes.push(oNode);
            if (!isNaN(oNode.x) &&
                oNode.x !== 0 &&
                !isNaN(oNode.y) &&
                oNode.y !== 0) {
                allHaveNoPosition = false;
            }
            else {
                oNode.x = Math.random() * 100;
                oNode.y = Math.random() * 100;
            }
            outerNodeIds.push(cTree.id);
            (0, util_1.traverseTreeUp)(cTree, function (child) {
                if (child.id !== cTree.id)
                    nodeAncestorIdMap[child.id] = cTree.id;
                return true;
            });
        });
        nodes.forEach(function (node) {
            if (node.comboId && comboMap[node.comboId])
                return;
            // 代表节点的节点
            var oNode = __assign({}, node);
            outerNodes.push(oNode);
            if (!isNaN(oNode.x) &&
                oNode.x !== 0 &&
                !isNaN(oNode.y) &&
                oNode.y !== 0) {
                allHaveNoPosition = false;
            }
            else {
                oNode.x = Math.random() * 100;
                oNode.y = Math.random() * 100;
            }
            outerNodeIds.push(node.id);
        });
        var outerEdges = [];
        edges.concat(comboEdges).forEach(function (edge) {
            var sourceAncestorId = nodeAncestorIdMap[edge.source] || edge.source;
            var targetAncestorId = nodeAncestorIdMap[edge.target] || edge.target;
            // 若两个点的祖先都在力导图的节点中，且是不同的节点，创建一条链接两个祖先的边到力导图的边中
            if (sourceAncestorId !== targetAncestorId &&
                outerNodeIds.includes(sourceAncestorId) &&
                outerNodeIds.includes(targetAncestorId)) {
                outerEdges.push({
                    source: sourceAncestorId,
                    target: targetAncestorId,
                });
            }
        });
        // 若有需要最外层的 combo 或节点，则对最外层执行力导向
        if (outerNodes === null || outerNodes === void 0 ? void 0 : outerNodes.length) {
            if (outerNodes.length === 1) {
                outerNodes[0].x = center[0];
                outerNodes[0].y = center[1];
            }
            else {
                var outerData = {
                    nodes: outerNodes,
                    edges: outerEdges,
                };
                // 需要使用一个同步的布局
                // @ts-ignore
                var outerLayout = this.outerLayout ||
                    new _1.GForceLayout({
                        gravity: 1,
                        factor: 4,
                        linkDistance: function (edge, source, target) {
                            var _a, _b;
                            var nodeSize = ((((_a = source.size) === null || _a === void 0 ? void 0 : _a[0]) || 30) + (((_b = target.size) === null || _b === void 0 ? void 0 : _b[0]) || 30)) / 2;
                            return Math.min(nodeSize * 1.5, 700);
                        },
                    });
                var outerLayoutType = (_a = outerLayout.getType) === null || _a === void 0 ? void 0 : _a.call(outerLayout);
                outerLayout.updateCfg({
                    center: center,
                    kg: 5,
                    preventOverlap: true,
                    animate: false,
                });
                // 若所有 outerNodes 都没有位置，且 outerLayout 是力导家族的布局，则先执行 preset mds 或 grid
                if (allHaveNoPosition && constants_1.FORCE_LAYOUT_TYPE_MAP[outerLayoutType]) {
                    var outerLayoutPreset = outerNodes.length < 100 ? new _1.MDSLayout() : new _1.GridLayout();
                    outerLayoutPreset.layout(outerData);
                }
                outerLayout.layout(outerData);
            }
            // 根据外部布局结果，平移 innerGraphs 中的节点（第一层）
            outerNodes.forEach(function (outerNode) {
                var innerGraph = innerGraphs[outerNode.id];
                if (!innerGraph) {
                    var node = nodeMap[outerNode.id];
                    if (node) {
                        node.x = outerNode.x;
                        node.y = outerNode.y;
                    }
                    return;
                }
                innerGraph.visited = true;
                innerGraph.x = outerNode.x;
                innerGraph.y = outerNode.y;
                innerGraph.nodes.forEach(function (node) {
                    node.x += outerNode.x;
                    node.y += outerNode.y;
                });
            });
        }
        // 至上而下遍历树处理下面各层节点位置
        var innerGraphIds = Object.keys(innerGraphs);
        var _loop_1 = function (i) {
            var id = innerGraphIds[i];
            var innerGraph = innerGraphs[id];
            if (!innerGraph)
                return "continue";
            innerGraph.nodes.forEach(function (node) {
                if (!innerGraph.visited) {
                    node.x += innerGraph.x || 0;
                    node.y += innerGraph.y || 0;
                }
                if (nodeMap[node.id]) {
                    nodeMap[node.id].x = node.x;
                    nodeMap[node.id].y = node.y;
                }
            });
            if (comboMap[id]) {
                comboMap[id].x = innerGraph.x;
                comboMap[id].y = innerGraph.y;
            }
        };
        for (var i = innerGraphIds.length - 1; i >= 0; i--) {
            _loop_1(i);
        }
        return { nodes: nodes, edges: edges, combos: combos, comboEdges: comboEdges };
    };
    ComboCombinedLayout.prototype.getInnerGraphs = function (nodeMap) {
        var self = this;
        var comboTrees = self.comboTrees, nodeSize = self.nodeSize, edges = self.edges, comboPadding = self.comboPadding, spacing = self.spacing;
        var innerGraphs = {};
        // @ts-ignore
        var innerGraphLayout = this.innerLayout ||
            new _1.ConcentricLayout({ type: 'concentric', sortBy: 'id' });
        innerGraphLayout.center = [0, 0];
        innerGraphLayout.preventOverlap = true;
        innerGraphLayout.nodeSpacing = spacing;
        (comboTrees || []).forEach(function (ctree) {
            (0, util_1.traverseTreeUp)(ctree, function (treeNode) {
                var _a;
                // @ts-ignore
                var padding = (comboPadding === null || comboPadding === void 0 ? void 0 : comboPadding(treeNode)) || 10; // 返回的最大值
                if ((0, util_1.isArray)(padding))
                    padding = Math.max.apply(Math, padding);
                if (!((_a = treeNode.children) === null || _a === void 0 ? void 0 : _a.length)) {
                    // 空 combo
                    if (treeNode.itemType === 'combo') {
                        var treeNodeSize = padding
                            ? [padding * 2, padding * 2]
                            : [30, 30];
                        innerGraphs[treeNode.id] = {
                            id: treeNode.id,
                            nodes: [],
                            size: treeNodeSize,
                        };
                    }
                }
                else {
                    // 非空 combo
                    var innerGraphNodes = treeNode.children.map(function (child) {
                        if (child.itemType === 'combo')
                            return innerGraphs[child.id];
                        var oriNode = nodeMap[child.id] || {};
                        return __assign(__assign({}, oriNode), child);
                    });
                    var innerGraphNodeIds_1 = innerGraphNodes.map(function (node) { return node.id; });
                    var innerGraphData = {
                        nodes: innerGraphNodes,
                        edges: edges.filter(function (edge) {
                            return innerGraphNodeIds_1.includes(edge.source) &&
                                innerGraphNodeIds_1.includes(edge.target);
                        }),
                    };
                    var minNodeSize_1 = Infinity;
                    innerGraphNodes.forEach(function (node) {
                        var _a;
                        // @ts-ignore
                        if (!node.size)
                            node.size = ((_a = innerGraphs[node.id]) === null || _a === void 0 ? void 0 : _a.size) ||
                                (nodeSize === null || nodeSize === void 0 ? void 0 : nodeSize(node)) || [30, 30];
                        if ((0, util_1.isNumber)(node.size))
                            node.size = [node.size, node.size];
                        if (minNodeSize_1 > node.size[0])
                            minNodeSize_1 = node.size[0];
                        if (minNodeSize_1 > node.size[1])
                            minNodeSize_1 = node.size[1];
                    });
                    // 根据节点数量、spacing，调整布局参数
                    innerGraphLayout.layout(innerGraphData);
                    var _b = (0, util_1.getLayoutBBox)(innerGraphNodes), minX = _b.minX, minY = _b.minY, maxX = _b.maxX, maxY = _b.maxY;
                    // move the innerGraph to [0, 0],for later controled by parent layout
                    var center_1 = { x: (maxX + minX) / 2, y: (maxY + minY) / 2 };
                    innerGraphData.nodes.forEach(function (node) {
                        node.x -= center_1.x;
                        node.y -= center_1.y;
                    });
                    var innerGraphWidth = Math.max(maxX - minX, minNodeSize_1) + padding * 2;
                    var innerGraphHeight = Math.max(maxY - minY, minNodeSize_1) + padding * 2;
                    innerGraphs[treeNode.id] = {
                        id: treeNode.id,
                        nodes: innerGraphNodes,
                        size: [innerGraphWidth, innerGraphHeight],
                    };
                }
                return true;
            });
        });
        return innerGraphs;
    };
    ComboCombinedLayout.prototype.initVals = function () {
        var self = this;
        var nodeSize = self.nodeSize;
        var spacing = self.spacing;
        var nodeSizeFunc;
        var spacingFunc;
        // nodeSpacing to function
        if ((0, util_1.isNumber)(spacing)) {
            spacingFunc = function () { return spacing; };
        }
        else if ((0, util_1.isFunction)(spacing)) {
            spacingFunc = spacing;
        }
        else {
            spacingFunc = function () { return 0; };
        }
        this.spacing = spacingFunc;
        // nodeSize to function
        if (!nodeSize) {
            nodeSizeFunc = function (d) {
                var spacing = spacingFunc(d);
                if (d.size) {
                    if ((0, util_1.isArray)(d.size)) {
                        var res = d.size[0] > d.size[1] ? d.size[0] : d.size[1];
                        return (res + spacing) / 2;
                    }
                    if ((0, util_1.isObject)(d.size)) {
                        var res = d.size.width > d.size.height ? d.size.width : d.size.height;
                        return (res + spacing) / 2;
                    }
                    return (d.size + spacing) / 2;
                }
                return 10 + spacing / 2;
            };
        }
        else if ((0, util_1.isFunction)(nodeSize)) {
            nodeSizeFunc = function (d) {
                var size = nodeSize(d);
                var spacing = spacingFunc(d);
                if ((0, util_1.isArray)(d.size)) {
                    var res = d.size[0] > d.size[1] ? d.size[0] : d.size[1];
                    return (res + spacing) / 2;
                }
                return ((size || 10) + spacing) / 2;
            };
        }
        else if ((0, util_1.isArray)(nodeSize)) {
            var larger = nodeSize[0] > nodeSize[1] ? nodeSize[0] : nodeSize[1];
            var radius_1 = larger / 2;
            nodeSizeFunc = function (d) { return radius_1 + spacingFunc(d) / 2; };
        }
        else {
            // number type
            var radius_2 = nodeSize / 2;
            nodeSizeFunc = function (d) { return radius_2 + spacingFunc(d) / 2; };
        }
        this.nodeSize = nodeSizeFunc;
        // comboPadding to function
        var comboPadding = self.comboPadding;
        var comboPaddingFunc;
        if ((0, util_1.isNumber)(comboPadding)) {
            comboPaddingFunc = function () { return comboPadding; };
        }
        else if ((0, util_1.isArray)(comboPadding)) {
            comboPaddingFunc = function () { return Math.max.apply(null, comboPadding); };
        }
        else if ((0, util_1.isFunction)(comboPadding)) {
            comboPaddingFunc = comboPadding;
        }
        else {
            // null type
            comboPaddingFunc = function () { return 0; };
        }
        this.comboPadding = comboPaddingFunc;
    };
    ComboCombinedLayout.prototype.getType = function () {
        return 'comboCombined';
    };
    return ComboCombinedLayout;
}(base_1.Base));
exports.ComboCombinedLayout = ComboCombinedLayout;
//# sourceMappingURL=comboCombined.js.map