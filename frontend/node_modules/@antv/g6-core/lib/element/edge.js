"use strict";

var _tslib = require("tslib");
var _util = require("@antv/util");
var _graphic = require("../util/graphic");
var _math = require("../util/math");
var _path = require("../util/path");
var _global = _interopRequireDefault(require("../global"));
var _shape = _interopRequireDefault(require("./shape"));
var _shapeBase = require("./shapeBase");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
/**
 * @fileOverview 自定义边
 * @description 自定义边中有大量逻辑同自定义节点重复，虽然可以提取成为 mixin ，但是考虑到代码的可读性，还是单独实现。
 */

var CLS_SHAPE = 'edge-shape';
// start,end 倒置，center 不变
function revertAlign(labelPosition) {
  var textAlign = labelPosition;
  if (labelPosition === 'start') {
    textAlign = 'end';
  } else if (labelPosition === 'end') {
    textAlign = 'start';
  }
  return textAlign;
}
var singleEdge = {
  itemType: 'edge',
  /**
   * 文本的位置
   * @type {String}
   */
  labelPosition: 'center',
  /**
   * 文本的 x 偏移
   * @type {Number}
   */
  refX: 0,
  /**
   * 文本的 y 偏移
   * @type {Number}
   */
  refY: 0,
  /**
   * 文本是否跟着线自动旋转，默认 false
   * @type {Boolean}
   */
  labelAutoRotate: false,
  // 自定义边时的配置
  options: {
    size: _global.default.defaultEdge.size,
    style: {
      x: 0,
      y: 0,
      stroke: _global.default.defaultEdge.style.stroke,
      lineAppendWidth: _global.default.defaultEdge.style.lineAppendWidth
    },
    labelCfg: {
      style: {
        fill: _global.default.edgeLabel.style.fill,
        fontSize: _global.default.edgeLabel.style.fontSize,
        fontFamily: _global.default.windowFontFamily
      }
    },
    stateStyles: (0, _tslib.__assign)({}, _global.default.edgeStateStyles)
  },
  /**
   * 获取边的 path
   * @internal 供扩展的边覆盖
   * @param  {Array} points 构成边的点的集合
   * @return {Array} 构成 path 的数组
   */
  getPath: function getPath(points) {
    var path = [];
    (0, _util.each)(points, function (point, index) {
      if (index === 0) {
        path.push(['M', point.x, point.y]);
      } else {
        path.push(['L', point.x, point.y]);
      }
    });
    return path;
  },
  getShapeStyle: function getShapeStyle(cfg) {
    var defaultStyle = this.options.style;
    var strokeStyle = {
      stroke: cfg.color
    };
    // 如果设置了color，则覆盖默认的stroke属性
    var style = (0, _util.mix)({}, defaultStyle, strokeStyle, cfg.style);
    var size = cfg.size || _global.default.defaultEdge.size;
    cfg = this.getPathPoints(cfg);
    var startPoint = cfg.startPoint,
      endPoint = cfg.endPoint;
    var controlPoints = this.getControlPoints(cfg);
    var points = [startPoint]; // 添加起始点
    // 添加控制点
    if (controlPoints) {
      points = points.concat(controlPoints);
    }
    // 添加结束点
    points.push(endPoint);
    var path = this.getPath(points);
    var styles = (0, _util.mix)({}, _global.default.defaultEdge.style, {
      stroke: _global.default.defaultEdge.color,
      lineWidth: size,
      path: path
    }, style);
    return styles;
  },
  updateShapeStyle: function updateShapeStyle(cfg, item, updateType) {
    var _a;
    var group = item.getContainer();
    // const strokeStyle: ShapeStyle = {
    //   stroke: cfg.color,
    // };
    var shape = ((_a = item.getKeyShape) === null || _a === void 0 ? void 0 : _a.call(item)) || group['shapeMap']['edge-shape']; // group.find((element) => element.get('className') === 'edge-shape');
    var size = cfg.size;
    cfg = this.getPathPoints(cfg);
    var startPoint = cfg.startPoint,
      endPoint = cfg.endPoint;
    var controlPoints = this.getControlPoints(cfg); // || cfg.controlPoints;
    var points = [startPoint]; // 添加起始点
    // 添加控制点
    if (controlPoints) {
      points = points.concat(controlPoints);
    }
    // 添加结束点
    points.push(endPoint);
    var currentAttr = shape.attr();
    // const previousStyle = mix({}, strokeStyle, currentAttr, cfg.style);
    var previousStyle = cfg.style || {};
    if (previousStyle.stroke === undefined) {
      previousStyle.stroke = cfg.color;
    }
    var source = cfg.sourceNode;
    var target = cfg.targetNode;
    var routeCfg = {
      radius: previousStyle.radius
    };
    if (!controlPoints) {
      routeCfg = {
        source: source,
        target: target,
        offset: previousStyle.offset,
        radius: previousStyle.radius
      };
    }
    var path = this.getPath(points, routeCfg);
    var style = {};
    if (updateType === 'move') {
      style = {
        path: path
      };
    } else {
      if (currentAttr.endArrow && previousStyle.endArrow === false) {
        cfg.style.endArrow = {
          path: ''
        };
      }
      if (currentAttr.startArrow && previousStyle.startArrow === false) {
        cfg.style.startArrow = {
          path: ''
        };
      }
      style = (0, _tslib.__assign)({}, cfg.style);
      if (style.lineWidth === undefined) style.lineWdith = ((0, _util.isNumber)(size) ? size : size === null || size === void 0 ? void 0 : size[0]) || currentAttr.lineWidth;
      if (style.path === undefined) style.path = path;
      if (style.stroke === undefined) style.stroke = currentAttr.stroke || cfg.color;
    }
    if (shape) {
      shape.attr(style);
    }
  },
  getLabelStyleByPosition: function getLabelStyleByPosition(cfg, labelCfg, group) {
    var labelPosition = labelCfg.position || this.labelPosition; // 文本的位置用户可以传入
    var style = {};
    var pathShape = group === null || group === void 0 ? void 0 : group['shapeMap'][CLS_SHAPE]; // group?.find((element) => element.get('className') === CLS_SHAPE);
    // 不对 pathShape 进行判空，如果线不存在，说明有问题了
    var pointPercent;
    if (labelPosition === 'start') {
      pointPercent = 0;
    } else if (labelPosition === 'end') {
      pointPercent = 1;
    } else {
      pointPercent = 0.5;
    }
    // 偏移量
    var offsetX = labelCfg.refX || this.refX;
    var offsetY = labelCfg.refY || this.refY;
    // 如果两个节点重叠，线就变成了一个点，这时候label的位置，就是这个点 + 绝对偏移
    if (cfg.startPoint.x === cfg.endPoint.x && cfg.startPoint.y === cfg.endPoint.y) {
      style.x = cfg.startPoint.x + offsetX;
      style.y = cfg.startPoint.y + offsetY;
      style.text = cfg.label;
      return style;
    }
    var autoRotate;
    if ((0, _util.isNil)(labelCfg.autoRotate)) autoRotate = this.labelAutoRotate;else autoRotate = labelCfg.autoRotate;
    var offsetStyle = (0, _graphic.getLabelPosition)(pathShape, pointPercent, offsetX, offsetY, autoRotate);
    style.x = offsetStyle.x;
    style.y = offsetStyle.y;
    style.rotate = offsetStyle.rotate;
    style.textAlign = this._getTextAlign(labelPosition, offsetStyle.angle);
    style.text = cfg.label;
    return style;
  },
  getLabelBgStyleByPosition: function getLabelBgStyleByPosition(label, labelCfg) {
    if (!label) {
      return {};
    }
    var bbox = label.getBBox();
    var backgroundStyle = labelCfg.style && labelCfg.style.background;
    if (!backgroundStyle) {
      return {};
    }
    var padding = backgroundStyle.padding;
    var backgroundWidth = bbox.width + padding[1] + padding[3];
    var backgroundHeight = bbox.height + padding[0] + padding[2];
    var style = (0, _tslib.__assign)((0, _tslib.__assign)({}, backgroundStyle), {
      width: backgroundWidth,
      height: backgroundHeight,
      x: bbox.minX - padding[3],
      y: bbox.minY - padding[0],
      matrix: [1, 0, 0, 0, 1, 0, 0, 0, 1]
    });
    var autoRotate;
    if ((0, _util.isNil)(labelCfg.autoRotate)) autoRotate = this.labelAutoRotate;else autoRotate = labelCfg.autoRotate;
    if (autoRotate) {
      style.matrix = label.attr('matrix') || [1, 0, 0, 0, 1, 0, 0, 0, 1];
    }
    return style;
  },
  // 获取文本对齐方式
  _getTextAlign: function _getTextAlign(labelPosition, angle) {
    var textAlign = 'center';
    if (!angle) {
      return labelPosition;
    }
    angle = angle % (Math.PI * 2); // 取模
    if (labelPosition !== 'center') {
      if (angle >= 0 && angle <= Math.PI / 2 || angle >= 3 / 2 * Math.PI && angle < 2 * Math.PI) {
        textAlign = labelPosition;
      } else {
        textAlign = revertAlign(labelPosition);
      }
    }
    return textAlign;
  },
  /**
   * @internal 获取边的控制点
   * @param  {Object} cfg 边的配置项
   * @return {Array} 控制点的数组
   */
  getControlPoints: function getControlPoints(cfg) {
    return cfg.controlPoints;
  },
  /**
   * @internal 处理需要重计算点和边的情况
   * @param {Object} cfg 边的配置项
   * @return {Object} 边的配置项
   */
  getPathPoints: function getPathPoints(cfg) {
    return cfg;
  },
  /**
   * 绘制边
   * @override
   * @param  {Object} cfg   边的配置项
   * @param  {G.Group} group 边的容器
   * @return {IShape} 图形
   */
  drawShape: function drawShape(cfg, group) {
    var shapeStyle = this.getShapeStyle(cfg);
    var shape = group.addShape('path', {
      className: CLS_SHAPE,
      name: CLS_SHAPE,
      attrs: shapeStyle
    });
    group['shapeMap'][CLS_SHAPE] = shape;
    return shape;
  },
  drawLabel: function drawLabel(cfg, group) {
    var defaultLabelCfg = this.options.labelCfg;
    var labelCfg = (0, _util.deepMix)({}, defaultLabelCfg, cfg.labelCfg);
    var labelStyle = this.getLabelStyle(cfg, labelCfg, group);
    var rotate = labelStyle.rotate;
    delete labelStyle.rotate;
    var label = group.addShape('text', {
      attrs: labelStyle,
      name: 'text-shape',
      labelRelated: true,
      draggable: true
    });
    group['shapeMap']['text-shape'] = label;
    if (!isNaN(rotate) && rotate !== '') {
      label.rotateAtStart(rotate);
    }
    if (labelStyle.background) {
      var rect = this.drawLabelBg(cfg, group, label, labelStyle, rotate);
      var labelBgClassname = this.itemType + _shapeBase.CLS_LABEL_BG_SUFFIX;
      rect.set('classname', labelBgClassname);
      group['shapeMap'][labelBgClassname] = rect;
      label.toFront();
    }
    return label;
  },
  drawLabelBg: function drawLabelBg(cfg, group, label, labelStyle, rotate) {
    var defaultLabelCfg = this.options.labelCfg;
    var labelCfg = (0, _util.deepMix)({}, defaultLabelCfg, cfg.labelCfg);
    var style = this.getLabelBgStyleByPosition(label, labelCfg);
    var rect = group.addShape('rect', {
      name: 'text-bg-shape',
      attrs: style,
      labelRelated: true
    });
    group['shapeMap']['text-bg-shape'] = rect;
    return rect;
  }
};
var singleEdgeDef = (0, _tslib.__assign)((0, _tslib.__assign)({}, _shapeBase.shapeBase), singleEdge);
_shape.default.registerEdge('single-edge', singleEdgeDef);
// 直线, 不支持控制点
_shape.default.registerEdge('line', {
  // 控制点不生效
  getControlPoints: function getControlPoints() {
    return undefined;
  }
}, 'single-edge');
// 直线
_shape.default.registerEdge('spline', {
  getPath: function getPath(points) {
    var path = (0, _path.getSpline)(points);
    return path;
  }
}, 'single-edge');
_shape.default.registerEdge('arc', {
  curveOffset: 20,
  clockwise: 1,
  getControlPoints: function getControlPoints(cfg) {
    var startPoint = cfg.startPoint,
      endPoint = cfg.endPoint;
    var midPoint = {
      x: (startPoint.x + endPoint.x) / 2,
      y: (startPoint.y + endPoint.y) / 2
    };
    var center;
    var arcPoint;
    // 根据给定点计算圆弧
    if (cfg.controlPoints !== undefined) {
      arcPoint = cfg.controlPoints[0];
      center = (0, _math.getCircleCenterByPoints)(startPoint, arcPoint, endPoint);
      // 根据控制点和直线关系决定 clockwise值
      if (startPoint.x <= endPoint.x && startPoint.y > endPoint.y) {
        this.clockwise = center.x > arcPoint.x ? 0 : 1;
      } else if (startPoint.x <= endPoint.x && startPoint.y < endPoint.y) {
        this.clockwise = center.x > arcPoint.x ? 1 : 0;
      } else if (startPoint.x > endPoint.x && startPoint.y <= endPoint.y) {
        this.clockwise = center.y < arcPoint.y ? 0 : 1;
      } else {
        this.clockwise = center.y < arcPoint.y ? 1 : 0;
      }
      // 若给定点和两端点共线，无法生成圆弧，绘制直线
      if ((arcPoint.x - startPoint.x) / (arcPoint.y - startPoint.y) === (endPoint.x - startPoint.x) / (endPoint.y - startPoint.y)) {
        return [];
      }
    } else {
      // 根据直线连线中点的的偏移计算圆弧
      // 若用户给定偏移量则根据其计算，否则按照默认偏移值计算
      if (cfg.curveOffset === undefined) {
        cfg.curveOffset = this.curveOffset;
      }
      if ((0, _util.isArray)(cfg.curveOffset)) {
        cfg.curveOffset = cfg.curveOffset[0];
      }
      if (cfg.curveOffset < 0) {
        this.clockwise = 0;
      } else {
        this.clockwise = 1;
      }
      var vec = {
        x: endPoint.x - startPoint.x,
        y: endPoint.y - startPoint.y
      };
      var edgeAngle = Math.atan2(vec.y, vec.x);
      arcPoint = {
        x: cfg.curveOffset * Math.cos(-Math.PI / 2 + edgeAngle) + midPoint.x,
        y: cfg.curveOffset * Math.sin(-Math.PI / 2 + edgeAngle) + midPoint.y
      };
      center = (0, _math.getCircleCenterByPoints)(startPoint, arcPoint, endPoint);
    }
    var radius = (0, _math.distance)(startPoint, center);
    var controlPoints = [{
      x: radius,
      y: radius
    }];
    return controlPoints;
  },
  getPath: function getPath(points) {
    var path = [];
    path.push(['M', points[0].x, points[0].y]);
    // 控制点与端点共线
    if (points.length === 2) {
      path.push(['L', points[1].x, points[1].y]);
    } else {
      path.push(['A', points[1].x, points[1].y, 0, 0, this.clockwise, points[2].x, points[2].y]);
    }
    return path;
  }
}, 'single-edge');
_shape.default.registerEdge('quadratic', {
  curvePosition: 0.5,
  curveOffset: -20,
  getControlPoints: function getControlPoints(cfg) {
    var controlPoints = cfg.controlPoints; // 指定controlPoints
    if (!controlPoints || !controlPoints.length) {
      var startPoint = cfg.startPoint,
        endPoint = cfg.endPoint;
      if (cfg.curveOffset === undefined) cfg.curveOffset = this.curveOffset;
      if (cfg.curvePosition === undefined) cfg.curvePosition = this.curvePosition;
      if ((0, _util.isArray)(cfg.curveOffset)) cfg.curveOffset = cfg.curveOffset[0];
      if ((0, _util.isArray)(cfg.curvePosition)) cfg.curvePosition = cfg.curveOffset[0];
      var innerPoint = (0, _path.getControlPoint)(startPoint, endPoint, cfg.curvePosition, cfg.curveOffset);
      controlPoints = [innerPoint];
    }
    return controlPoints;
  },
  getPath: function getPath(points) {
    var path = [];
    path.push(['M', points[0].x, points[0].y]);
    path.push(['Q', points[1].x, points[1].y, points[2].x, points[2].y]);
    return path;
  }
}, 'single-edge');
_shape.default.registerEdge('cubic', {
  curvePosition: [1 / 2, 1 / 2],
  curveOffset: [-20, 20],
  getControlPoints: function getControlPoints(cfg) {
    var controlPoints = cfg.controlPoints; // 指定 controlPoints
    if (cfg.curveOffset === undefined) cfg.curveOffset = this.curveOffset;
    if (cfg.curvePosition === undefined) cfg.curvePosition = this.curvePosition;
    if ((0, _util.isNumber)(cfg.curveOffset)) cfg.curveOffset = [cfg.curveOffset, -cfg.curveOffset];
    if ((0, _util.isNumber)(cfg.curvePosition)) cfg.curvePosition = [cfg.curvePosition, 1 - cfg.curvePosition];
    if (!controlPoints || !controlPoints.length || controlPoints.length < 2) {
      var startPoint = cfg.startPoint,
        endPoint = cfg.endPoint;
      var innerPoint1 = (0, _path.getControlPoint)(startPoint, endPoint, cfg.curvePosition[0], cfg.curveOffset[0]);
      var innerPoint2 = (0, _path.getControlPoint)(startPoint, endPoint, cfg.curvePosition[1], cfg.curveOffset[1]);
      controlPoints = [innerPoint1, innerPoint2];
    }
    return controlPoints;
  },
  getPath: function getPath(points) {
    var path = [];
    path.push(['M', points[0].x, points[0].y]);
    path.push(['C', points[1].x, points[1].y, points[2].x, points[2].y, points[3].x, points[3].y]);
    return path;
  }
}, 'single-edge');
// 垂直方向的三阶贝塞尔曲线，不再考虑用户外部传入的控制点
_shape.default.registerEdge('cubic-vertical', {
  curvePosition: [1 / 2, 1 / 2],
  minCurveOffset: [0, 0],
  curveOffset: undefined,
  getControlPoints: function getControlPoints(cfg) {
    var startPoint = cfg.startPoint,
      endPoint = cfg.endPoint;
    if (cfg.curvePosition === undefined) cfg.curvePosition = this.curvePosition;
    if (cfg.curveOffset === undefined) cfg.curveOffset = this.curveOffset;
    if (cfg.minCurveOffset === undefined) cfg.minCurveOffset = this.minCurveOffset;
    if ((0, _util.isNumber)(cfg.curveOffset)) cfg.curveOffset = [cfg.curveOffset, -cfg.curveOffset];
    if ((0, _util.isNumber)(cfg.minCurveOffset)) cfg.minCurveOffset = [cfg.minCurveOffset, -cfg.minCurveOffset];
    if ((0, _util.isNumber)(cfg.curvePosition)) cfg.curvePosition = [cfg.curvePosition, 1 - cfg.curvePosition];
    var yDist = endPoint.y - startPoint.y;
    var curveOffset = [0, 0];
    if (cfg.curveOffset) {
      curveOffset = cfg.curveOffset;
    } else if (Math.abs(yDist) < Math.abs(cfg.minCurveOffset[0])) {
      curveOffset = cfg.minCurveOffset;
    }
    var innerPoint1 = {
      x: startPoint.x,
      y: startPoint.y + yDist * this.curvePosition[0] + curveOffset[0]
    };
    var innerPoint2 = {
      x: endPoint.x,
      y: endPoint.y - yDist * this.curvePosition[1] + curveOffset[1]
    };
    return [innerPoint1, innerPoint2];
  }
}, 'cubic');
// 水平方向的三阶贝塞尔曲线，不再考虑用户外部传入的控制点
_shape.default.registerEdge('cubic-horizontal', {
  curvePosition: [1 / 2, 1 / 2],
  minCurveOffset: [0, 0],
  curveOffset: undefined,
  getControlPoints: function getControlPoints(cfg) {
    var startPoint = cfg.startPoint,
      endPoint = cfg.endPoint;
    if (cfg.curvePosition === undefined) cfg.curvePosition = this.curvePosition;
    if (cfg.curveOffset === undefined) cfg.curveOffset = this.curveOffset;
    if (cfg.minCurveOffset === undefined) cfg.minCurveOffset = this.minCurveOffset;
    if ((0, _util.isNumber)(cfg.curveOffset)) cfg.curveOffset = [cfg.curveOffset, -cfg.curveOffset];
    if ((0, _util.isNumber)(cfg.minCurveOffset)) cfg.minCurveOffset = [cfg.minCurveOffset, -cfg.minCurveOffset];
    if ((0, _util.isNumber)(cfg.curvePosition)) cfg.curvePosition = [cfg.curvePosition, 1 - cfg.curvePosition];
    var xDist = endPoint.x - startPoint.x;
    var curveOffset = [0, 0];
    if (cfg.curveOffset) {
      curveOffset = cfg.curveOffset;
    } else if (Math.abs(xDist) < Math.abs(cfg.minCurveOffset[0])) {
      curveOffset = cfg.minCurveOffset;
    }
    var innerPoint1 = {
      x: startPoint.x + xDist * this.curvePosition[0] + curveOffset[0],
      y: startPoint.y
    };
    var innerPoint2 = {
      x: endPoint.x - xDist * this.curvePosition[1] + curveOffset[1],
      y: endPoint.y
    };
    var controlPoints = [innerPoint1, innerPoint2];
    return controlPoints;
  }
}, 'cubic');
_shape.default.registerEdge('loop', {
  getPathPoints: function getPathPoints(cfg) {
    return (0, _graphic.getLoopCfgs)(cfg);
  },
  getControlPoints: function getControlPoints(cfg) {
    return cfg.controlPoints;
  },
  afterDraw: function afterDraw(cfg) {
    cfg.controlPoints = undefined;
  },
  afterUpdate: function afterUpdate(cfg) {
    cfg.controlPoints = undefined;
  }
}, 'cubic');