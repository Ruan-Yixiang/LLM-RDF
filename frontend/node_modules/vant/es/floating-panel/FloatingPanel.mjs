import { createVNode as _createVNode } from "vue";
import { computed, defineComponent, ref, watch } from "vue";
import { addUnit, createNamespace, makeArrayProp, makeNumericProp, truthProp } from "../utils/index.mjs";
import { useWindowSize } from "@vant/use";
import { useLockScroll } from "../composables/use-lock-scroll.mjs";
import { useTouch } from "../composables/use-touch.mjs";
import { useSyncPropRef } from "../composables/use-sync-prop-ref.mjs";
const {
  height: windowHeight
} = useWindowSize();
const floatingPanelProps = {
  height: makeNumericProp(0),
  anchors: makeArrayProp(),
  duration: makeNumericProp(0.2),
  contentDraggable: truthProp,
  safeAreaInsetBottom: truthProp
};
const [name, bem] = createNamespace("floating-panel");
const DAMP = 0.2;
var stdin_default = defineComponent({
  name,
  props: floatingPanelProps,
  emits: ["heightChange", "update:height"],
  setup(props, {
    emit,
    slots
  }) {
    const rootRef = ref();
    const contentRef = ref();
    const height = useSyncPropRef(() => +props.height, (value) => emit("update:height", value));
    const boundary = computed(() => {
      var _a, _b;
      return {
        min: (_a = props.anchors[0]) != null ? _a : 100,
        max: (_b = props.anchors[props.anchors.length - 1]) != null ? _b : Math.round(windowHeight.value * 0.6)
      };
    });
    const anchors = computed(() => props.anchors.length >= 2 ? props.anchors : [boundary.value.min, boundary.value.max]);
    const dragging = ref(false);
    const rootStyle = computed(() => ({
      height: addUnit(boundary.value.max),
      transform: `translateY(calc(100% + ${addUnit(-height.value)}))`,
      transition: !dragging.value ? `transform ${props.duration}s` : "none"
    }));
    const ease = (moveY) => {
      const absDistance = Math.abs(moveY);
      const {
        min,
        max
      } = boundary.value;
      if (absDistance > max) {
        return -(max + (absDistance - max) * DAMP);
      }
      if (absDistance < min) {
        return -(min - (min - absDistance) * DAMP);
      }
      return moveY;
    };
    const closest = (arr, target) => arr.reduce((pre, cur) => Math.abs(pre - target) < Math.abs(cur - target) ? pre : cur);
    let startY;
    const touch = useTouch();
    const onTouchstart = (e) => {
      touch.start(e);
      dragging.value = true;
      startY = -height.value;
    };
    const onTouchmove = (e) => {
      var _a;
      touch.move(e);
      const target = e.target;
      if (contentRef.value === target || ((_a = contentRef.value) == null ? void 0 : _a.contains(target))) {
        if (!props.contentDraggable)
          return;
        if (-startY < boundary.value.max) {
          if (e.cancelable)
            e.preventDefault();
          e.stopPropagation();
        } else if (!(contentRef.value.scrollTop <= 0 && touch.deltaY.value > 0)) {
          return;
        }
      }
      const moveY = touch.deltaY.value + startY;
      height.value = -ease(moveY);
    };
    const onTouchend = () => {
      dragging.value = false;
      height.value = closest(anchors.value, height.value);
      if (height.value !== -startY) {
        emit("heightChange", {
          height: height.value
        });
      }
    };
    watch(boundary, () => {
      height.value = closest(anchors.value, height.value);
    }, {
      immediate: true
    });
    useLockScroll(rootRef, () => true);
    return () => {
      var _a;
      return _createVNode("div", {
        "class": [bem(), {
          "van-safe-area-bottom": props.safeAreaInsetBottom
        }],
        "ref": rootRef,
        "style": rootStyle.value,
        "onTouchstartPassive": onTouchstart,
        "onTouchmove": onTouchmove,
        "onTouchend": onTouchend,
        "onTouchcancel": onTouchend
      }, [_createVNode("div", {
        "class": bem("header")
      }, [_createVNode("div", {
        "class": bem("header-bar")
      }, null)]), _createVNode("div", {
        "class": bem("content"),
        "ref": contentRef
      }, [(_a = slots.default) == null ? void 0 : _a.call(slots)])]);
    };
  }
});
export {
  stdin_default as default,
  floatingPanelProps
};
